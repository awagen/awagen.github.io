<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Step-by-Step Guide on Kolibri Documentation</title><link>http://awagen.github.io/kolibri/kolibri-base/3-step-by-step/</link><description>Recent content in Step-by-Step Guide on Kolibri Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 05 Dec 2021 20:22:00 +0200</lastBuildDate><atom:link href="http://awagen.github.io/kolibri/kolibri-base/3-step-by-step/index.xml" rel="self" type="application/rss+xml"/><item><title>Values</title><link>http://awagen.github.io/kolibri/kolibri-base/3-step-by-step/0-values/</link><pubDate>Wed, 08 Dec 2021 08:30:00 +0200</pubDate><guid>http://awagen.github.io/kolibri/kolibri-base/3-step-by-step/0-values/</guid><description>Values In the following let&amp;rsquo;s look into which structures Kolibri provides to simplify definitions of values.
OrderedValues trait OrderedValues[+T] extends KolibriSerializable { val name: String val totalValueCount: Int def getNthZeroBased(n: Int): Option[T] def getNFromPositionZeroBased(position: Int, n: Int): Seq[T] def getAll: Seq[T] } Two distinct implementations:
Using explicitly passed values: case class DistinctValues[+T](name: String, values: Seq[T]) extends OrderedValues[T] Range with defined start, end and stepSize case class RangeValues[T:Fractional](name: String, start:T, end:T, stepSize:T)(implicit v: Numeric[T]) extends OrderedValues[T] OrderedMultiValues Container for multiple OrderedValues with methods to edit (remove, add) values and methods to retrieve the n-th element out of the permutation over all contained OrderedValues.</description></item><item><title>Generators</title><link>http://awagen.github.io/kolibri/kolibri-base/3-step-by-step/1-generators/</link><pubDate>Sun, 05 Dec 2021 20:22:00 +0200</pubDate><guid>http://awagen.github.io/kolibri/kolibri-base/3-step-by-step/1-generators/</guid><description>Generators Definition of the data is done via instances of type IndexedGenerator. Possible values for those can be found in the package de.awagen.kolibri.datatypes.collections.generators (GitHub Link). These can hold single collections of values or combinations of multiple collections. By using the right combination of those, all kinds of permutations of values can be composed.
So lets say you had multiple stores (lets say identified by storeIds), and they are classified into certain types, and you wanted to request certain queries pro store type.</description></item><item><title>Tagging</title><link>http://awagen.github.io/kolibri/kolibri-base/3-step-by-step/2-tags/</link><pubDate>Sun, 05 Dec 2021 22:47:00 +0200</pubDate><guid>http://awagen.github.io/kolibri/kolibri-base/3-step-by-step/2-tags/</guid><description>Tagging Coming shortly :)</description></item><item><title>Processing Messages / Aggregation States</title><link>http://awagen.github.io/kolibri/kolibri-base/3-step-by-step/3-processing-messages/</link><pubDate>Sun, 05 Dec 2021 22:47:00 +0200</pubDate><guid>http://awagen.github.io/kolibri/kolibri-base/3-step-by-step/3-processing-messages/</guid><description>Processing Messages And AggregationStates Single processing units are represented by instances of type ProcessingMessage. This allows enriching of values with tags, which can be used for selective result handling, such as result writing, aggregations and selective handling of values.
Completion of a single batch is signalled by message of type AggregationState. This can be of two types:
AggregationStateWithoutData: provide info about completed batch without the generated data AggregationStateWithData: provide info about completed batch with the generated data trait AggregationState[+T] extends KolibriSerializable with TaggedWithType { val jobID: String val batchNr: Int val executionExpectation: ExecutionExpectation } case class AggregationStateWithoutData[+V](containedElementCount: Int, jobID: String, batchNr: Int, executionExpectation: ExecutionExpectation) extends AggregationState[V] case class AggregationStateWithData[+V](data: V, jobID: String, batchNr: Int, executionExpectation: ExecutionExpectation) extends AggregationState[V]</description></item><item><title>Formats &amp; Writers</title><link>http://awagen.github.io/kolibri/kolibri-base/3-step-by-step/4-writers/</link><pubDate>Mon, 03 Jan 2022 09:20:00 +0200</pubDate><guid>http://awagen.github.io/kolibri/kolibri-base/3-step-by-step/4-writers/</guid><description>Formats &amp;amp; Writers Coming shortly :)</description></item></channel></rss>